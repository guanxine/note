## 三个核心问题
1. 分工(性能): 高效的拆解任务并分配给线程. 如何分工:Executor,Fork/Join,Future, 生产者-消费者, Thread-Pre-Message, Worker Thread 
2. 同步(性能): 线程之间如何协作。分工之后就是具体执行了，执行过程中，任务之间有依赖。一个任务结束后，如何通知后续的任务开始执行。可以描述为：当某个条件不满足时线程需要等待，当某个条件满足时，线程需要被唤醒执行。解决协作的核心问题是：管程
3. 互斥(安全): 同一时刻只允许一个线程访问共享资源. 当不同的线程访问一个共享变量时，结果是不确定的。不确定的源头是可见性问题，有序性问题，原子性问题。为了解决这三个问题，Java 引入了内存模型，提供了一些列规则，利用这些规则可以解决可见性，有序性。但是不足以完全解决线程安全问题。解决线程安全的核心方案：互斥。方法：
锁，无锁，不共享变量(ThreadLocal)或变量只读(final)
例子
生产者消费者:大厨和服务员，大厨就是生产者，负责做菜，放到出菜口，而服务员就是消费者。把做好的菜端过来。优点，生产者一个一个的生产数据，而消费者可以批处理。提高了性能

## 并发bug
1. 缓存导致可见性：一个线程对共享变量的修改，另一个线程能够立刻看到。我们称为可见性。当多个线程在一个cpu上执行时，操作同一个cpu缓存没有可见性问题。当多个线程不在不同的cpu上执行时，这些线程操作的是不同的cpu缓存。这时cpu缓存和内存的数据一致性就没那么容易解决。
2. 线程切换导致原子性：操作系统允许某个进程执行一小段时间，例如50ms(时间片),过了这个时间，操作系统重新选择一个进程来执行。一个条语句(count+=1)往往需要多条cpu指令完成。我们把一个或这多个操作在cpu执行过程中不被中断的特性成为原子性。cpu能保证原子操作是指令级别的，而不是高级语言的操作符。因此我们需要在高级语言层面保证操作的原子性。
3. 编译优化带来的有序性
```
A a = new A();
顺序
1. 分配一块内存M
2. 在内存 M 上初始化 A 对象
3. 然后把 M 的地址赋值给 a
指令重排后
1. 分配一块内存M
2. 将 M 的地址赋值给 a 
3. 最后在内存 M 上初始化 A 对象
```

## java 内存模型(可见性，有序性)
导致可见性的原因是缓存，导致有序性的原因是编译优化
解决办法：按需禁用缓存和编译优化
Java 的内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法：volatile（禁用cpu缓存，增强）, synchronized,final. 以及6项 Happens-Before 规则

Happens-before（语义 可见性 A happens-before B 意味着 A 事件对 B 事件来说总是可见的， 无论 A 和 B 是否发生在同一个线程里）
前一个操作的结果对后续操作是可见的。编译器优化后一定遵循 Happens-before 原则。
1. 程序顺序性
2. volatile 规则， 对一个 volatile 变量的写操作， Happens-before 于后续对这个 volatile 变量的读操作。对于一个 volatile 变量的写操作相对于后续对这个volatile 变量的读操作可见
3. 传递性：A happens-before B 且 B happens-before C. 那么 A happens-before C.
4. 管程中锁的规则：对一个锁的解锁 Happens-before 于后续对这个锁的加锁。管程是一种通用的同步原语。在 Java 中就是 synchronized.
5. 线程 start() 规则：主线程 A 启动子线程 B 后, 子线程 B 能够看到主线程在启动子线程 B 前的操作。
6. 线程 join() 规则：主线程 A 等待子线程 B 完成（主线程 A 调用子线程 B 的 join() 方法实现），当子线程 B 完成后，主线程能够看到子线程的操作（共享变量）

## 原子性：线程切换
原子性的源头：线程切换(操作系统进行线程切换是依赖 cpu 中断的)
在32位 cpu 上 long（64位）的写操作被拆为两次写操作（高位32位和低位32位）， 在多核场景下，有可能两个线程在同时运行。可能会出现两个线程同时写高位的情况。
互斥：同一时刻只有一个线程执行
解决原子性问题：要保证中间状态对外不可见

1. 简易锁模型： 加锁->临界区->解锁
把需要互斥执行的代码成为临界区
锁的是什么？保护的是什么？-> 用自家的锁保护自家的资源

2. 改进锁模型：创建保护资源R的锁（LR）-> 加锁操作：lock(LR) -> 临界区：一段代码(受保护资源R) -> 解锁操作：unlock(LR)
3. synchronized： 不能改变操作系统线程切换的特点，只是其他线程要访问这个资源时，发现锁还未释放。所以只能在外面等。
修饰静态方法：锁定的是当前 class 对象
修饰非静态方法：锁定的是当前实例对象 this， 不能用可变对象做锁

4. 锁和受保护资源的关系
受保护资源和锁之间的关联关系是 N:1 的关系。和现实不同，不能用多把锁来保护同一个资源。可以用一把锁保护多个资源。

## 多个资源
1. 多个资源没有关联关系
2. 多个资源有关联关系

## 死锁（细粒度）
下面四个条件都发生才会出现死锁
1. 互斥: 共享资源 X 和 Y 只能被一个线程占用。
2. 占有等待: 线程 T1 已经获取资源 X， 在等待共享资源 Y 的时候，不释放共享资源X
3. 不可抢占: 其他线程不能抢占线程T1占有的资源
4. 循环等待: 线程 T1 等待线程 T2 占用资源，线程 T2 等待 T1 占用的资源

破坏其中一个就可避免死锁。
1. 互斥没办法破坏，锁就是互斥
2. 占用等待：一次性申请所有资源。
3. 不可占用：占用部分资源的线程，进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。等待-通知, wait() 释放了锁
4. 循环等待：按序申请资源。先申请资源序号小的，再申请资源序号大的。

## 等待通知
当线程要求的条件不满足时，线程阻塞，进入等待状态。当线程要求的条件满足时，通知等待的线程重新执行。
synchronized 配合 wait(),notify(),notifyAll() 这几个方法在 synchronized 内部调用 
```
 while(条件不满足) { wait(); }

```

## 安全性问题
数据竞争：多个线程同时读写同一个数据。
竞态条件：程序的执行结果依赖线程执行的顺序。多线程中线程的执行顺序不一样，如果存在竞态条件，则执行结果不确定。而执行结果不确定这可是个大bug. 条件不是显示的，
## 活跃性问题（死锁）
某个操作无法执行下去
1. 活锁：没有发生阻塞，但仍然执行不下去。让两个线程随机等待不同的时间后切换。Raft 分布式一致性算法用到了它。
2. 饥饿：线程无法访问所需要的资源。
  + 保证资源充足
  + 公平分配资源： 适用场景更多，公平锁，先来后到，线程的等待是有顺序的。排在队列前面的线程优先获取资源。
  + 避免持有锁的线程长时间执行

## 性能问题
“锁” 过度使用可能导致串行化
1. 无锁的算法和数据结构：线程本地存储(Thread Local Storage, TLS), 写入时复制(copy-on-write),乐观锁等， Java 原子类无锁结构，Disruptor 无锁队列
2. 减少锁持有时间，互斥锁的本质将并行的程序串行化。
  + 使用细粒度锁：ConcurrentHashMap，采用了分段锁的技术
  + 读写锁: 读是无锁的，只有写的时候才会互斥。
性能方面给有3个指标
1. 吞吐量: 单位时间内能处理的请求数量，吞吐量越高，性能越好
2. 延迟: 发出请求到收到响应的时间，延迟越小，性能越好
3. 并发量:能同时处理的请求数量，一般来说并发量增加，延迟也会增加。所以延迟是基于并发量来说的。比如并发1000，延迟是50毫秒 

## 管程
管理共享变量以及对共享变量的操作过程，让他们支持并发。
Java: 管理类成员变量和成员方法。让这个类线程安全。

并发两大核心问题
1. 互斥：同一时刻只允许一个线程访问共享资源
2. 同步：线程之间如何通信，协作

MESA 模型
每个条件变量都对应一个等待队列。
1. 入队，队列满，等到队列不满（notFull.await()）, 入队后，队列就不空了，通知（队列不空）条件变量:可通知出队。
2. 出队，队列空，等待队列不空 (notEmpty.await())，出队后，队列就不满了，通知（队列不满）条件变量：可通知入队。

## 生命周期
通用线程的生命周期：
1. 初始状态
2. 可运行状态
3. 运行状态
4. 休眠状态
5. 终止状态

Java 中线程生命周期
1. NEW
2. RUNNABLE
  3. BLOCKED, 4. WAITING, 5. TIMED_WAITING: 细分了休眠状态，只要 JAVA 处于这三种状态之一，那么这个线程永远没有 CPU 使用权。
6. TERMINATED

RUNNABLE 和 BLOCKED 相互转换： synchronized 修饰的方法或者代码块
RUNNABLE 和 WAITING 相互转换：Object.wait()/ threadA.join()/
RUNNABLE 和 TIMED_WAITING 相互转换：Thread.sleep(time)/Object.wait(time)


stop 和 interrupt 区别

stop 杀死线程，如果有 ReentrantLock 锁，不会 unlock() 释放锁。
interrupt 仅仅通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。
两种方式收到通知
1. 异常: 调用 ta.interrupt()（中断标志）, 当 ta 处于 WAITING,TIMED_WAITING 状态时，会使线程返回到RUNNABLE状态，并抛出 InterruptedException， 并且中断标志被清楚了。
2. 主动检测: 当调用了 ta.interrupt()，当 ta 处于 RUNNABLE 并且没有阻塞在 IO 操作上，可通过 ta.isInterrupted 方法检测自己是不是被中断了


